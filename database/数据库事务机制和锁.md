# 数据库事务和锁机制

## 事务

+ 主要是解决在并发事务处理中，数据资源在并发访问过程中的不一致的问题。

### 事务特性

​	**什么是事务？**完成一个操作需要满足四个特性，这四个特性构成了事务。

+ 原子性（Atomic）：事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。
+ 一致性（consistency）：事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。
+ 隔离性（Isolation）：由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。
+ 持久性（Durablity）：事务结束后，事务处理的结果必须能够得到固化，即写入数据库文件中即使机器宕机数据也不会丢失，它对于系统的影响是永久性的。

### 事务的并发控制

​	**并发事务中数据不一致**的主要问题如下。

+ **丢失更新（Update Lost）**

  + 回滚丢失
  + 覆盖丢失

+ **脏读（Dirty Read）**

  ~~~
  此种异常时因为一个事务读取了另一个事务修改了但是未提交的数据。
  ~~~

+ **不可重复读（Not Repeatable Read）**（值的变化）

  ~~~
  此种异常是一个事务对同一行数据执行了两次或更多次查询，但是却得到了不同的结果，也就是在一个事务里面你不能重复（即多次）读取一行数据，如果你这么做了，不能保证每次读取的结果是一样的，有可能一样有可能不一样。造成这个结果是在两次查询之间有别的事务对该行数据做了更新操作。举个例子，事务一先查询了count，值为100，此时事务二更新了count=101，事务一再次读取count,值就会变成101，两次读取结果不一样。
  ~~~

+ **幻读（Phantom Read）**（行的变化）

  ~~~markdown
  幻读和不可重复读有点像，只是针对的不是数据的值而是数据的数量。此种异常是一个事务在两次查询的过程中数据的数量不同，让人以为发生幻觉，幻读大概就是这么得来的吧。举个例子，事务一查询order表有多少条记录，事务二新增了一条记录，然后事务一查了一下order表有多少记录，发现和第一次不一样，这就是幻读。
  ~~~

由此，数据库的**事务隔离级别**登场。

### 事务的隔离级别

`数据库的事务隔离级别实现`一般是通过`数据库锁`实现的。

#### 四种隔离级别

+ 读未提交（**Read Uncommitted**）

  **极易出错，没有安全性可言，基本不会使用。**

  ~~~
  该隔离级别指即使一个事务的更新语句没有提交,但是别的事务可以读到这个改变，几种异常情况都可能出现。
  ~~~

+ 读已提交（**Read Committed**）

  **消除了脏读和第一类丢失更新（即回滚丢失），这是大多数数据库的默认隔离级别，如Oracle,Sqlserver。**

  ~~~
  该隔离级别指一个事务只能看到其他事务的已经提交的更新，看不到未提交的更新。
  ~~~

+ 可重复读（**Repeatable Read**）

  **消除了不可重复读和第二类更新丢失**，这是Mysql数据库的`默认隔离级别`。

  ~~~
  该隔离级别指一个事务中进行两次或多次同样的对于数据内容的查询，得到的结果是一样的，但不保证对于数据条数的查询是一样的，只要存在读该行数据就禁止写。
  注：读数据的时，禁止更新，即可保证多次读取的数据是一致的。
  ~~~

+ 串行化（**Serializable**）

  **这是事务隔离的最高级别，虽然最安全最省心，但是效率太低，一般不会用。**

  ~~~
  意思是说这个事务执行的时候不允许别的事务并发执行.完全串行化的读，只要存在读就禁止写,但可以同时读，消除了幻读。
  ~~~

**下面是各种隔离级别对各异常的控制能力：**

| 级别\异常 | 更新回滚丢失 | 更新覆盖丢失 | 脏读 | 不可重复读 | 幻读 |
| :-------: | :----------: | :----------: | :--: | :--------: | :--: |
| 读未提交  |      Y       |      Y       |  Y   |     Y      |  Y   |
| 读已提交  |      N       |      Y       |  N   |     Y      |  Y   |
| 可重复读  |      N       |      N       |  N   |     N      |  Y   |
|  串行化   |      N       |      N       |  N   |     N      |  N   |

#### 总结

~~~markdown
针对并发事务中数据的不一致问题，数据引出了事务的隔离级别来解决这个问题。级别越高，系统数据安全性越高，但是性能越低。
而事务的隔离级别实际上是通过**数据库锁**实现的。下面我们来了解数据库锁。
~~~

## 数据库锁

解决数据不一致的办法就是通过数据加锁控制。数据库锁有两种加锁思路，**乐观锁和悲观锁**。

### 悲观锁

+ `优点`
  1.  **乐观锁机制避免了长事务中的数据库加锁解锁开销**
  2. **大大提升了大并发量下的系统整体性能表现**

#### 排他锁（Exclusive Lock）

**顾名思义，很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人拿这个数据就会block（阻塞），直到它拿锁。**

> 产生排他锁的SQL语句如下：select * from ad_plan for update;

> **性质** 
> 1. 仅允许一个事务封锁此页； 
> 2. 其他任何事务必须等到X锁被释放才能对该页进行访问； 
> 3. X锁一直到事务结束才能被释放。

#### 共享锁（Share Lock）

**S锁，也叫读锁，用于所有的只读数据操作。共享锁是非独占的，允许多个并发事务读取其锁定的资源。 **

> **性质** 
> 1. 多个事务可封锁同一个共享页； 
> 2. 任何事务都不能修改该页； 
> 3. 通常是该页被读取完毕，S锁立即被释放。

> 在SQL Server中，默认情况下，数据被读取后，立即释放共享锁。 
> 例如，执行查询语句“SELECT * FROM my_table”时，首先锁定第一页，读取之后，释放对第一页的锁定，然后锁定第二页。这样，就允许在读操作过程中，修改未被锁定的第一页。 
>
> 例如，语句“SELECT * FROM my_table HOLDLOCK”就要求在整个查询过程中，保持对表的锁定，直到查询完成才释放锁定。

#### 更新锁

**U锁，在修改操作的初始化阶段用来锁定可能要被修改的资源，这样可以避免使用共享锁造成的死锁现象。**

> 因为当使用共享锁时，修改数据的操作分为两步： 
> 1. 首先获得一个共享锁，读取数据， 
> 2. 然后将共享锁升级为排他锁，再执行修改操作。 
> 这样如果有两个或多个事务同时对一个事务申请了共享锁，在修改数据时，这些事务都要将共享锁升级为排他锁。这时，这些事务都不会释放共享锁，而是一直等待对方释放，这样就造成了死锁。 
> 如果一个数据在修改前直接申请更新锁，在数据修改时再升级为排他锁，就可以避免死锁。

#### 作用范围划分

##### **行锁**（InnoDB默认）

>锁的作用范围是行级别，数据库能够确定那些行需要锁的情况下使用行锁，如果不知道会影响哪些行的时候就会使用表锁。举个例子，一个用户表user，有主键id和用户生日birthday当你使用update ... where id=?这样的语句数据库明确知道会影响哪一行，它就会使用行锁，当你使用update ... where birthday=?这样的的语句的时候因为事先不知道会影响哪些行就可能会使用表锁。

##### **表锁**(MyISAM默认)

> 锁的作用范围是整张表。

### 乐观锁

> 顾名思义，就是很乐观，每次自己操作数据的时候认为没有人回来修改它，所以不去加锁，但是在更新的时候会去判断在此期间数据有没有被修改，需要用户自己去实现。既然都有数据库提供的悲观锁可以方便使用为什么要使用乐观锁呢？对于读操作远多于写操作的时候，大多数都是读取，这时候一个更新操作加锁会阻塞所有读取，降低了吞吐量。最后还要释放锁，锁是需要一些开销的，我们只要想办法解决极少量的更新操作的同步问题。换句话说，如果是读写比例差距不是非常大或者你的系统没有响应不及时，吞吐量瓶颈问题，那就不要去使用乐观锁，它增加了复杂度，也带来了额外的风险。

+ `优点`

  > 1. **乐观锁机制避免了长事务中的数据库加锁解锁开销**
  > 2. **大大提升了大并发量下的系统整体性能表现**

#### *乐观锁实现方式：*

-  **版本号（记为version）**：就是给数据增加一个版本标识，在数据库上就是表中增加一个version字段，每次更新把这个字段加1，读取数据的时候把version读出来，更新的时候比较version，如果还是开始读取的version就可以更新了，如果现在的version比老的version大，说明有其他事务更新了该数据，并增加了版本号，这时候得到一个无法更新的通知，用户自行根据这个通知来决定怎么处理，比如重新开始一遍。这里的关键是判断version和更新两个动作需要作为一个原子单元执行，否则在你判断可以更新以后正式更新之前有别的事务修改了version，这个时候你再去更新就可能会覆盖前一个事务做的更新，造成第二类丢失更新，所以你可以使用update ... where ... and version="old version"这样的语句，根据返回结果是0还是非0来得到通知，如果是0说明更新没有成功，因为version被改了，如果返回非0说明更新成功。
-  **时间戳（timestamp）**：和版本号基本一样，只是通过时间戳来判断而已，注意时间戳要使用数据库服务器的时间戳不能是业务系统的时间。
-  **待更新字段**：和版本号方式相似，只是不增加额外字段，直接使用有效数据字段做版本控制信息，因为有时候我们可能无法改变旧系统的数据库表结构。假设有个待更新字段叫count,先去读取这个count,更新的时候去比较数据库中count的值是不是我期望的值（即开始读的值），如果是就把我修改的count的值更新到该字段，否则更新失败。java的基本类型的原子类型对象如AtomicInteger就是这种思想。
-  **所有字段**：和待更新字段类似，只是使用所有字段做版本控制信息，只有所有字段都没变化才会执行更新。

#### **乐观锁几种方式的区别：**

> 新系统设计可以使用version方式和timestamp方式，需要增加字段，应用范围是整条数据，不论那个字段修改都会更新version,也就是说两个事务更新同一条记录的两个不相关字段也是互斥的，不能同步进行。旧系统不能修改数据库表结构的时候使用数据字段作为版本控制信息，不需要新增字段，待更新字段方式只要其他事务修改的字段和当前事务修改的字段没有重叠就可以同步进行，并发性更高。

### 意向锁

### 更新锁

