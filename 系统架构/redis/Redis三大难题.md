
# Redis三大难题
+ 缓存雪崩
+ 缓存穿透
+ 缓存击穿


## 缓存雪崩
> 当redis缓存数据在某一个时间点大量失效，会引起缓存雪崩效应。
> 因为，当大量缓存失效后，客户端的大量请求会去请求数据库，大量并发请求
> 会导致数据库压力过大，数据库直接挂掉。这时，如果你选择重启数据库，
> 依然由大量并发再次请求落到数据库服务，数据库再次挂掉。这就是常见的
> 雪崩效应。

+ 解决方案：
    + 数据key的过期时间随机生成，防止缓存失效在某一个时间点瞬间爆发导致集体失效
    + 设置热点数据永远不过期，只有当热点数据更新时，刷新缓存数据

## 缓存穿透
> 客户端请求的数据同时在redis缓存和数据库中都不存在，同时绕开了缓存和数据库
> 的一种穿透效应。如果并发高一点，会导致服务崩溃。比如数据的自增主键是从1开始自增，
> 这是客户端请求的主键是-1，缓存中不存在，数据库中也不存在。这是一种攻击行为。

+ 解决方案：
    + 增加参数校验，无效参数，直接返回
    + 数据库也不存在的数据，设置该key的value为null，并设置过期时间。


## 缓存击穿
> 在大并发请求热点数据的场景下，某一个热点数据失效后，在热点数据失效到热点数据
> 重新更新至缓存中的这个时间段，大量并发请求会去请求数据库引起的缓存击穿效应。
> 它与缓存雪崩类似，但又不同。缓存雪崩是大量缓存失效，导致大量请求落到数据库；
> 而缓存击穿是少量热点缓存失效，大并发请求该热点数据引起的数据库压力。
> 通俗一点的说，`缓存雪崩`就像，`多个战士`拿着`手枪`从各个方向向数据库这个水桶射击，导致水桶漏水；
> 而`缓存击穿`更新`一个战士`拿着`机关枪`朝一个方向射击数据库水桶，导致水桶漏水；

+ 解决方案：
    + 设置缓存永久有效
    + 当缓存失效，在查询数据库更新缓存阶段添加互斥锁，加锁成功请求数据库并更新缓存，加锁不成功，sleep一段时间，再次请求缓存



事前：Redis 高可用，主从+哨兵，Redis cluster，避免全盘崩溃。
事中：本地 ehcache 缓存 + Hystrix 限流+降级，避免 MySQL 被打死。
事后：Redis 持久化 RDB+AOF，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。

