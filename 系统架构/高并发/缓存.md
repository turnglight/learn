# 缓存

## 1.应用级缓存
经典缓存例子：
+ CUP->L1/L2/L3->内存->磁盘
+ MAVEN->本机仓库->远程仓库
## 1.1 缓存回收策略
+ 基于空间（单条缓存空间）
+ 基于容量（多条缓存条目数）
+ 基于时间
    + TTL(time to live): 存活期
    + TTI(time to idle): 空闲期
+ 基于JAVA对象（JVM）
    + 软引用
    + 弱引用
## 1.2 回收算法
+ FIFO(first in first out): 先进先出算法
+ LRU(Least Recenly Used): 最近最少使用算法
+ LFU(Least Frequently Used): 最不常用算法
实际应用中基于LRU的缓存居多， 如Guava Cache、Ehcache支持LRU。

## 1.3 JAVA缓存类型
+ 堆内缓存（无需序列化，可直接使用，是最快的缓存，但GC暂时时间更长）
+ 堆外缓存（更短的GC暂时时间，更大的缓存空间，读取数据需要序列化，速度更慢）
+ 磁盘缓存（在JVM重启时，堆缓存都会消失，但磁盘缓存可以重新加载）
+ 分布式缓存
    + 在多台JVM下缓存存在一下问题
        + 单机容量问题
        + 数据一致性问题（可以通过设置缓存过期时间解决）
        + 缓存不命中问题（多实例会导致数据库的访问量增多）

    + 从而引入分布式缓存
        + java进程间的分布式缓存
        + redis分布式缓存
+ 两种缓存模式
    + 单机时：存储最热的数据到堆缓存，相对热的数据到堆外缓存，不热的数据到磁盘缓存
    + 集群时：存储最热的数据到堆缓存，相对热的数据到堆外缓存，全量数据到分布式缓存

+ 三种常用缓存框架
    + Guava Cache: 只提供堆缓存，小巧灵活，性能最好，如果只使用堆缓存，那么使用它够了
    + Ehcache 3.x：提供堆内缓存、堆外缓存、磁盘缓存、分布式缓存（3.x的版本暂时不是很稳定，建议使用2.x，但2.x不使用堆外缓存）
    + MapDB: 是一款嵌入式JAVA数据库引擎和集合框架。提供了Maps\Sets\Lists\Queues\Bitmaps的支持，还支持ACID事务、增量备份。支持堆缓存、堆外缓存、磁盘缓存

> 对于分布式缓存，建议还是使用Redis，性能非常好，有主从模式、集群模式

## 2.HTTP缓存
+ Nginx HTTP缓存设置
    + Nginx作为静态资源服务器，可以使用expires进行缓存控制
~~~
    location /img {
        alias /export/img/;
        expires 1d;
    }
~~~
+ Nginx代理层缓存
    + 通过设置proxy buffer与proxy cache进行控制
## 3.多级缓存
> 所谓多级缓存，是指在整个系统架构的不同系统层级进行数据缓存，以提升访问效率
+ 多层级缓存流程如下
    + 访问Nginx代理服务器，利用负载均衡算法将请求分发到Nginx
    + Nginx服务读取本地缓存
    + 如果Nginx读取本地缓存没有命中，则读取分布式缓存
    + 如果分布式缓存没有命中，则回源到Tomcat集群，在回源到Tomcat集群时，也可以使用轮询和一致性哈希做负载均衡算法
    + 在Tomcat应用中，首先读取堆缓存
    + 如果堆缓存没有命中，可以再尝试一次Redis缓存
    + 如果所有缓存都没有命中，则最后只能读取DB，然后将读取到的数据异步写到Redis集群

### 3.1 如何缓存数据
+ 过期与不过期
+ 维度化缓存与增量缓存
+ 大Value
+ 热点缓存

### 3.2 更新缓存与原子性
> 如果多个应用同时操作一份数据，很可能导致缓存数据变成脏数据
+ 更新数据时使用更行时间戳或者版本对比，如果使用redis，则可以利用其单线程机制进行原子化更新
+ 使用Canal订阅数据库binlog
+ 将更新请求按照相应的规则分散到多个队列，然后每个队列进行单线程更新，更新时拉取最新的数据保存
+ 使用分布式锁，在更新之前获取锁

