# 并发编程的问题
> 并发编程原理，实际上主要是分析并发编程中存在的问题，以及如何解决这些问题

+ 原子性
+ 可见性
+ 有序性

## JMM
> 所谓原子性、可见性、有序性是在并发编程中存在的三大核心问题。解决这三大核心问题，JVM中引入了```JMM```（java内存模型）的概念。核心问题：

+ 缓存一致性导致的可见性问题(JMM内存模型中的总线嗅探机制，store指令经过总线，被嗅探到编程，直接修改缓存中的内存地址，令缓存失效。volatile利用MESI缓存一致性协议解决可见性问题)
+ 处理器的乱序执行会导致原子性问题(monitorenter, monitorexit)
+ 指令重排序导致的有序性问题(synchronized,volatile)

> Java内存模型的主要目标是定义程序中各个变量的访问规则，通过规则来控制线程间的资源竞争问题，保证并发场景下的可见性、原子性和有序性。

> 通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器有关。

> 它解决了 CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的可见性、原子性和有序性。

JMM流程图请查看```Java内存模型(JMM)```

### JMM如何解决原子性、可见性、有序性的问题？

+ 原子性： monitorenter/monitorexit高级指令，对应的关键字Synchronized来保证代码块内的操作是原子的
+ 可见性：volatile关键字提供了一个功能，修改的变量可以立即同步到主内存，被其修饰的变量在每次用之前都从主内存刷新。因此，可以试用volatile来保证多线程操作时变量的可见性。synchronized和final两个关键字也可以实现可见性
+ 有序性：synchronized和volatile保证多线程之间操作的有序性。实现方式有所区别：volatile关键字禁止指令重排。synchronized关键字保证同一时刻只允许一个线程操作。



## synchronized
> 在了解synchronized锁之前，我们需要了解两个重要的概念，一个是对象头、另一个是monitor。

### Java对象头
> 在Hotspot虚拟机中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充；java对象头是实现synchronized的锁对象的基础。

如果对象是数组类型，则JVM用3个字存储对象头；否则，使用2个字

长度 | 内容	| 说明
-|-|-|
32/64bit|mark word|存储对象的hashCode或者锁信息
32/64bit|Class metadata address|存储对象描述数据的指针
32/64bit|Array length|数组的长度（如果当前对象为数组）

#### mark word
> 用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等。

mark word有一个字节码的详细标记图，请上网查看，会更清晰。

### monitor
> 什么是Monitor？我们可以把它理解为一个同步工具，也可以描述为一种同步机制。所有的Java对象是天生的
Monitor，每个object的对象里 markOop->monitor() 里可以保存ObjectMonitor的对象。从源码层面分析一下monitor对象

##synchronized的锁升级和获取过程

了解了java对象头，和monitor再学习synchronized会容易得多。

synchronized的锁是进行过优化的，引入了偏向锁、轻量级锁；锁的级别从低到高逐步升级， 无锁->偏向锁->轻量级锁->重量级锁

+ 自旋锁（CAS）：不满足条件的线程等待一段时间，而不是立即挂起。执行一段没有任何意义的循环，在指定时间内如果其他线程没有释放锁，则停止自旋。以此避免线程切换的开销。
+ 偏向锁：在对象头的mark word中如果存有线程id，那么当该线程竞争锁时，可以直接获取锁。如果线程ID不匹配，则再校验mark word的偏向锁标记位。如果没有设置，则使用CAS竞争锁。如果设置了是偏向锁，则指向当前线程。
+ 轻量级锁：
+ 重量级锁




