# JVM

## JVM内存模型

JVM内存模型可以分为两个部分，如下图所示，**堆和方法区是所有线程共有的**，**而虚拟机栈，本地方法栈和程序计数器则是线程私有的。**

![JVM的内存分配、运行原理、回收算法机制](http://p3.pstatp.com/large/pgc-image/1536113360329e6822aef52)

### 堆

堆内存是所有线程共有的，可以分为两个部分：年轻代和老年代。下图中的Perm代表的是永久代，但是注意永久代并不属于堆内存中的一部分，**同时jdk1.8之后永久代也将被移除**。

![JVM的内存分配、运行原理、回收算法机制](http://p1.pstatp.com/large/pgc-image/1536113361185a0bc5812f6)

> 存放对象实例及数组

> - -Xms(最小值)，默认操作系统物理内存的1/64
> - -Xmx(最大值)，默认操作系统物理内存的1/4
> - XX:MinHeapFreeRation=?,当前空余堆内存的比例小于该值，则增加堆内存至-Xmx
> - XX:MaxHeapFreeRation=?,当前空余堆内存的比例大于该值，则调整堆内存至-Xms
> - 为了避免频繁调整，通常将-Xms与-Xmx设置成一样。
> - 堆内存=新生代+老年代+持久代

堆是java虚拟机所管理的内存中**最大的**一块内存区域，也是被各个**线程共享**的内存区域，该内存区域**存放了对象实例及数组（但不是所有的对象实例都在堆中）**。其大小通过-Xms(最小值)和-Xmx(最大值)参数设置（**最大最小值都要小于1G**），前者为启动时申请的最小内存，默认为操作系统物理内存的1/64，后者为JVM可申请的最大内存,默认为物理内存的1/4，**默认当空余堆内存小于40%时**，JVM会**增大**堆内存到-Xmx指定的大小，可通过-XX:MinHeapFreeRation=来指定这个比列；当**空余堆内存大于70%**时，JVM会**减小**堆内存的大小到-Xms指定的大小，可通过XX:MaxHeapFreeRation=来指定这个比列，当然为了避免在运行时频繁调整Heap的大小，**通常-Xms与-Xmx的值设成一样**。堆内存 = 新生代+老生代+持久代。在我们垃圾回收的时候，我们往往将堆内存分成**新生代和老生代（大小比例1：2）**，新生代中由Eden和Survivor0，Survivor1组成，**三者的比例是8：1：1**，新生代的回收机制采用**复制算法**，在Minor GC的时候，我们**都留一个存活区**用来**存放存活的对象**，真正进行的区域是Eden+其中一个存活区，当我们的对象时长超过一定年龄时（默认**15**，可以通过参数设置），将会把对象放入老生代，当然大的对象会直接进入老生代。老生代采用的回收算法是**标记整理算法。**

### 方法区

>存放虚拟机加载的类信息、常量、静态变量，是线程共享的内存区域。
>
>- -XX:PermSize
>- -XX:MaxPermSize

方法区也称"**永久代**"，它用于**存储虚拟机加载的类信息、常量、静态变量**、是各个**线程共享的内存区域**。默认最小值为16MB，最大值为64MB（64位JVM由于指针膨胀，默认是85M），可以通过-XX:PermSize 和 -XX:MaxPermSize 参数限制方法区的大小。它是**一片连续的堆空间**，永久代的**垃圾收集是和老年代(old generation)捆绑在一起的**，因此**无论谁满**了，**都会触发永久代和老年代的垃圾收集**。不过，一个明显的问题是，当JVM加载的类信息容量超过了参数-XX：MaxPermSize设定的值时，应用将会报OOM的错误。参数是通过-XX:PermSize和-XX：MaxPermSize来设定的。

### 虚拟机栈

> **存储局部变量表(包括参数)、操作栈、方法出口**

描述的是**java方法执行的内存模型**：每个**方法被执行的时候都会创建一个"栈帧"**,用于**存储局部变量表(包括参数)、操作栈、方法出口**等信息。每个方法被调用到执行完的过程，就**对应着一个栈帧在虚拟机栈中从入栈到出栈的过程**。**声明周期与线程相同，是线程私有的**。栈帧由三部分组成：局部变量区、操作数栈、帧数据区。局部变量区被组织为以一个字长为单位、从0开始计数的数组，和局部变量区一样，操作数栈也被组织成一个以字长为单位的数组。但和前者不同的是，它不是通过索引来访问的，而是通过入栈和出栈来访问的，可以看作为临时数据的存储区域。除了局部变量区和操作数栈外，java栈帧还需要一些数据来支持常量池解析、正常方法返回以及异常派发机制。这些数据都保存在java栈帧的帧数据区中。

**局部变量表: 存放**了编译器可知的各种**基本数据类型**、对象引用(引用指针，并非对象本身)，其中64位长度的long和double类型的数据会占用2个局部变量的空间，其余数据类型只占1个。局部变量表**所需的内存空间**在**编译期间完成分配**，当进入一个方法时，这个方法需要在栈帧中**分配多大的局部变量是完全确定**的，在**运行期间**栈帧**不会改变局部变量表的大小空间**。

### 本地方法栈

与虚拟机栈基本类似，区别在于**虚拟机栈为虚拟机执行的java方法服务**，而**本地方法栈则是为Native方法服务**。(栈的空间大小远远小于堆)

### 程序计数器

是**最小的一块内存区域**，它的**作用**是**当前线程所执行的字节码的行号指示器**，在虚拟机的模型里，字节码解释器工作时就是通过**改变这个计数器的值来选取下一条需要执行的字节码指令**，**分支**、**循环、异常处理、线程恢复**等基础功能都需要**依赖计数器**完成。

### 直接内存

直接内存并**不是虚拟机内存的一部分**，也不是Java虚拟机规范中定义的内存区域。jdk1.4中新加入的NIO，引入了通道与缓冲区的IO方式，它可以调用Native方法直接分配堆外内存，这个堆外内存就是本机内存，不会影响到堆内存的大小.

## JVM垃圾回收机制

### 复制

![阿里P8架构师谈：JVM的内存分配、运行原理、回收算法机制](http://p1.pstatp.com/large/pgc-image/153611936078493d1b7df79)



**原理：**

- 从根集合节点进行扫描，标记出所有的存活对象，并将这些存活的对象复制到一块儿新的内存（图中下边的那一块儿内存）上去，之后将原来的那一块儿内存（图中上边的那一块儿内存）全部回收掉

**适用场合：**

- 存活对象较少的情况下比较高效
- 扫描了整个空间一次（标记存活对象并复制移动）
- 适用于年轻代（即新生代）：基本上98%的对象是"朝生夕死"的，存活下来的会很少

**缺点：**

- 需要一块儿空的内存空间
- 需要复制移动对象

### 标记清除

![阿里P8架构师谈：JVM的内存分配、运行原理、回收算法机制](http://p3.pstatp.com/large/pgc-image/1536119514512d660e58a03)



**原理**：

- 从根集合节点进行扫描，标记出所有的存活对象，最后扫描整个内存空间并清除没有标记的对象（即死亡对象）

**适用场合**：

- 存活对象较多的情况下比较高效
- 适用于年老代（即旧生代）

**缺点：**

- 标记清除算法带来的一个问题是会存在大量的空间碎片，因为回收后的空间是不连续的，这样给大对象分配内存的时候可能会提前触发full gc。

### 标记整理

![阿里P8架构师谈：JVM的内存分配、运行原理、回收算法机制](http://p1.pstatp.com/large/pgc-image/1536119483005c850b7ec80)



**原理：**

- 从根集合节点进行扫描，标记出所有的存活对象，最后扫描整个内存空间并清除没有标记的对象（即死亡对象）（可以发现前边这些就是标记-清除算法的原理），清除完之后，将所有的存活对象左移到一起。

**适用场合：**

- 用于年老代（即旧生代）

**缺点：**

- 需要移动对象，若对象非常多而且标记回收后的内存非常不完整，可能移动这个动作也会耗费一定时间
- 扫描了整个空间两次（第一次：标记存活对象；第二次：清除没有标记的对象）

优点：

- 不会产生内存碎片

### 增量算法

增量算法的基本思想是，如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。

## 垃圾回收器

### **1.Serial收集器**

Serial收集器是最古老的收集器，它的缺点是当Serial收集器想进行垃圾回收的时候，必须暂停用户的所有进程，即stop the world。到现在为止，它依然是虚拟机运行在client模式下的默认新生代收集器，与其他收集器相比，对于限定在单个CPU的运行环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾回收自然可以获得最高的单线程收集效率。

### **2.ParNew收集器**

ParNew收集器是Serial收集器新生代的多线程实现，注意在进行垃圾回收的时候依然会stop the world，只是相比较Serial收集器而言它会运行多条进程进行垃圾回收。

ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百的保证能超越Serial收集器。当然，随着可以使用的CPU的数量增加，它对于GC时系统资源的利用还是很有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU非常多（譬如32个，现在CPU动辄4核加超线程，服务器超过32个逻辑CPU的情况越来越多了）的环境下，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。

### **3.Parallel Scavenge收集器**

Parallel是采用复制算法的多线程新生代垃圾回收器，似乎和ParNew收集器有很多的相似的地方。但是Parallel Scanvenge收集器的一个特点是它所关注的目标是吞吐量(Throughput)。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)。停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能够提升用户的体验；而高吞吐量则可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。

### **4.CMS收集器**

CMS(Concurrent Mark Swep)收集器是一个比较重要的回收器，现在应用非常广泛，我们重点来看一下，CMS一种获取最短回收停顿时间为目标的收集器，这使得它很适合用于和用户交互的业务。从名字(Mark Swep)就可以看出，CMS收集器是基于标记清除算法实现的。它的收集过程分为四个步骤：

1. 初始标记(initial mark)
2. 并发标记(concurrent mark)
3. 重新标记(remark)
4. 并发清除(concurrent sweep)

注意初始标记和重新标记还是会stop the world，但是在耗费时间更长的并发标记和并发清除两个阶段都可以和用户进程同时工作。

不过由于CMS收集器是基于标记清除算法实现的，会导致有大量的空间碎片产生，在为大对象分配内存的时候，往往会出现老年代还有很大的空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前开启一次Full GC。

为了解决这个问题，CMS收集器默认提供了一个-XX:+UseCMSCompactAtFullCollection收集开关参数（默认就是开启的)，用于在CMS收集器进行FullGC完开启内存碎片的合并整理过程，内存整理的过程是无法并发的，这样内存碎片问题倒是没有了，不过停顿时间不得不变长。虚拟机设计者还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction参数用于设置执行多少次不压缩的FULL GC后跟着来一次带压缩的（默认值为0，表示每次进入Full GC时都进行碎片整理）。

不幸的是，它作为老年代的收集器，却无法与jdk1.4中已经存在的新生代收集器Parallel Scavenge配合工作，所以在jdk1.5中使用cms来收集老年代的时候，新生代只能选择ParNew或Serial收集器中的一个。ParNew收集器是使用-XX:+UseConcMarkSweepGC选项启用CMS收集器之后的默认新生代收集器，也可以使用-XX:+UseParNewGC选项来强制指定它。

### **5.G1收集器**

G1收集器是一款面向服务端应用的垃圾收集器。HotSpot团队赋予它的使命是在未来替换掉JDK1.5中发布的CMS收集器。与其他GC收集器相比，G1具备如下特点：

1. 并行与并发：G1能更充分的利用CPU，多核环境下的硬件优势来缩短stop the world的停顿时间。
2. 分代收集：和其他收集器一样，分代的概念在G1中依然存在，不过G1不需要其他的垃圾回收器的配合就可以独自管理整个GC堆。
3. 空间整合：G1收集器有利于程序长时间运行，分配大对象时不会无法得到连续的空间而提前触发一次GC。
4. 可预测的非停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。

在使用G1收集器时，Java堆的内存布局和其他收集器有很大的差别，它将这个Java堆分为多个大小相等的独立区域，虽然还保留新生代和老年代的概念，但是新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。

虽然G1看起来有很多优点，实际上CMS还是主流。

## 与GC相关的常用参数

除了上面提及的一些参数，下面补充一些和GC相关的常用参数：

- -Xmx: 设置堆内存的最大值。
- -Xms: 设置堆内存的初始值。
- -Xmn: 设置新生代的大小。
- -Xss: 设置栈的大小。
- -PretenureSizeThreshold: 直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配。
- -MaxTenuringThrehold: 晋升到老年代的对象年龄。每个对象在坚持过一次Minor GC之后，年龄就会加1，当超过这个参数值时就进入老年代。
- -UseAdaptiveSizePolicy: 在这种模式下，新生代的大小、eden 和 survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。在手工调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量 (GCTimeRatio) 和停顿时间 (MaxGCPauseMills)，让虚拟机自己完成调优工作。
- -SurvivorRattio: 新生代Eden区域与Survivor区域的容量比值，默认为8，代表Eden: Suvivor= 8: 1。
- -XX:ParallelGCThreads：设置用于垃圾回收的线程数。通常情况下可以和 CPU 数量相等。但在 CPU 数量比较多的情况下，设置相对较小的数值也是合理的。
- -XX:MaxGCPauseMills：设置最大垃圾收集停顿时间。它的值是一个大于 0 的整数。收集器在工作时，会调整 Java 堆大小或者其他一些参数，尽可能地把停顿时间控制在 MaxGCPauseMills 以内。
- -XX:GCTimeRatio:设置吞吐量大小，它的值是一个 0-100 之间的整数。假设 GCTimeRatio 的值为 n，那么系统将花费不超过 1/(1+n) 的时间用于垃圾收集。

