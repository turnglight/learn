
# 索引

## 1.索引基数

基数是数据列所包含的不同值的数量。例如，某个数据列包含值1、3、7、4、7、3，那么它的基数就是4。索引的基数相对于数据表行数较高（也就是说，列中包含很多不同的值，重复的值很少）的时候，它的工作效果最好。如果某数据列含有很多不同的年龄，索引会很快地分辨数据行。如果某个数据列用于记录性别（只有"M"和"F"两种值），那么索引的用处就不大。如果值出现的几率几乎相等，那么无论搜索哪个值都可能得到一半的数据行。在这些情况下，最好根本不要使用索引，因为查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。惯用的百分比界线是"30%"

## 2. 设计索引的基本原则
+ 最适合索引的列是出现在 WHERE 子句中的列，或连接子句中指定的列，而不是出现在 SELECT 关键字后的选择列表中的列
+ 对于惟一值的列，索引的效果最好，而具有多个重复值的列，其索引效果最差
+ 使用短索引。如果一列中的前10或20个字符内，多数值是唯一的，那么不要对整个列进行索引。
    + 较小的索引设计的磁盘I/O较少，较短的值比较起来更快。
    + 更为重要的是，对于较短的键值，索引高速缓存中的块能容纳更多的键值，可以提升mysql的查询效率
+ 利用最左前缀（最左匹配）；例如index(‘c1’, ‘c2’, ‘c3’) ，where ‘c2’ = ‘aaa’ 不使用索引,where ‘c2’ = ‘aaa’ and ‘c3’ = ‘sss’ 不能使用索引。where ‘c1’ = ‘aaa’ and ‘c2’ = ‘bbb’ 可以使用索引
+ 不要过度索引
+ 考虑的列上的比较类型
+ 索引散列度；通过索引扫描的记录超过了表总行数的30%（估计值），则查询优化器认为全表扫描的效率更高，所以会变成全表扫描查询

## 3.索引失效
+ 在列上进行运算；
    + select * from users where YEAR(adddate)<2007; 将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成select * from users where adddate<‘2007-01-01’;
+ like语句操作；
    + select * from users where name like '%aaa%'不会使用索引 
+ 索引不会包含NULL列
    + 复合索引中如果有一列含有NULL值那么这个组合索引都将失效,一般需要给默认值0或者 ' '字符串
+ 隐式转换 
    + 隐式转换导致的索引失效。比如，表的字段tu_mdn定义为varchar(20),但在查询时把该字段作为number类型当做where条件,这样会导致索引失效. 错误的例子：select * from test where tu_mdn=13333333333; 正确的例子：select * from test where tu_mdn='13333333333’;
+ OR条件
    + 即使其中有条件带索引也不会使用（这也是为什么建议少使用or的原因），如果想使用or，又想索引有效，只能将or条件中的每个列加上索引
+ B-tree索引 is null不会走,is not null会走,位图索引 is null,is not null 都会走
+ 组合索引遵循最左原则
+ 对索引列进行运算导致索引失效,我所指的对索引列进行运算包括(+，-，*，/，! 等) 
    + 错误的例子：select * from test where id-1=9; 
    + 正确的例子：select * from test where id=10; 